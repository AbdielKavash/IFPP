#include "Types.h"
#include "Logger.h"
#include "Context.h"
#include "Compiler.h"

// Autogenerated files are not super strict.
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Weffc++"
#include "Parser.h"
#include "Lexer.h"
#pragma GCC diagnostic pop

#include <iostream>
#include <fstream>
#include <cstring>
#include <string>
#include <sstream>
#include <stdexcept>

#include <shlobj.h>

extern const int IFPP_VERSION_MAJOR = 2;
extern const int IFPP_VERSION_MINOR = 0;
extern const int IFPP_VERSION_PATCH = 0;
const char * POE_VERSION = "3.6";

int main(int argc, char ** argv) {
	std::string inFile(""), outFile(""), logFile("");
	/*
	std::string b = "folder\\folder\\filter";
	
	// Get the actual file name (not directories) of the filter.
	size_t pos = b.find_last_of("/\\");
	std::string filename;
	if (pos != std::string::npos) {
		filename = b.substr(pos + 1);
	} else {
		filename = b;
	}
	
	// Get the path to the documents folder.
	TCHAR docPath[MAX_PATH];
	if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_PERSONAL, NULL, 0, docPath))) {
		std::cout << docPath << std::endl;
	} else {
		std::cout << "Failure!" << std::endl;
	}
	
	filename = std::string() + docPath + '\\' + filename;
	std::cout << filename << std::endl;
	
	return 0;	
*/
	/*bool dLex = false;
	bool dParse = false;
	bool dPartial = false;
	bool dParseOnly = false;*/
	bool documents = false;

	for (int i = 1; i < argc; ++i) {
		/*
		if (!strcmp(argv[i], "-Dlex")) dLex = true;
		else if (!strcmp(argv[i], "-c")) logFile = "-";
				else if (!strcmp(argv[i], "-Dparse")) dParse = true;
		else if (!strcmp(argv[i], "-Dpartial")) dPartial = true;
		else if (!strcmp(argv[i], "-DparseOnly")) dParseOnly = true;
		*/
		
		// TODO: give a method to specify i/o/l files separately
		if (!strcmp(argv[i], "-d")) documents = true;
		else if (inFile == "") inFile = argv[i];
		else if (outFile == "") outFile = argv[i];
		else if (logFile == "") logFile = argv[i];
	}

	if (inFile == "") {
		std::cerr << "Error: No input file specified. Nothing to do." << std::endl;
		std::cerr << "Use: ifpp <input file> [output file] [log file]." << std::endl;
		return EXIT_FAILURE;
	}

	std::string baseName = inFile.substr(0, inFile.find_last_of('.'));
	if (outFile == "") outFile = baseName + ".filter";
	if (logFile == "") logFile = "-";

	// Exception handling depends on logStream to be open.
	std::ofstream logStream;
	if (logFile != "-") {
		logStream.open(logFile, std::ios_base::out);
		if (!logStream.is_open()) {
			std::cerr << "Error: Unable to open log file \"" << logFile << "\"!" << std::endl;
			std::cerr << "Processing aborted." << std::endl;
			return EXIT_FAILURE;
		}
	}
	ifpp::Logger log(logFile == "-" ? std::cerr : logStream);
	
	
	/*
	Main processing begins here.
	*/
	
	try {
		log.message() << "Item Filter PreProcessor, version "
			<< IFPP_VERSION_MAJOR << '.' << IFPP_VERSION_MINOR << '.' << IFPP_VERSION_PATCH << std::endl;
		log.message() << "Designed for compatibility with Path of Exile version "
			<< POE_VERSION << ", but should work with any later releases." << std::endl;
		log.message() << "Input file \"" << inFile << "\", output file \"" << outFile << "\", log file \"" << logFile << "\"." << std::endl;
		log.message() << std::endl;
		
		// Parse input file.

		ifpp::FilterIFPP inFilter;
		ifpp::Context ctx(inFile, inFilter, log);
		
		ctx.reset();
		ctx.parse();
		
		log.message() << "Parsing finished." << std::endl;
		log.message() << "\t" << ctx.countDef << " definitions" << std::endl;
		log.message() << "\t" << ctx.countIns << " instructions" << std::endl;
		log.message() << "\t" << ctx.countRule << " top-level rules" << std::endl << std::endl;
/*		
		if (dPartial) {
			std::ofstream parsedStream(baseName + ".parsed.ifpp", std::ios_base::out);
			ifpp::print(parsedStream, ifpp::PRINT_IFPP, inFilter);
			parsedStream.close();
		}
		
		if (dParseOnly) {
			logStream.close();
			return EXIT_SUCCESS;
		}
*/

		// Compile the filter.
	
		ifpp::FilterNative outFilter;

/*	
		std::ofstream partialStream;
		if (dPartial) partialStream.open(baseName + ".partial.ifpp", std::ios_base::out);
*/	
		ifpp::Compiler c(log, false, std::cerr);
		
		log.message() << "Compiler initialized." << std::endl;
		log.message() << "Compiling filter..." << std::endl;
		c.Compile(inFilter, outFilter);
		log.message() << "Compiling done." << std::endl;
		log.message() << "\tGenerated " << outFilter.size() << " native rules." << std::endl << std::endl;
		
/*
		if (dPartial) partialStream.close();
*/

		// Write the native filter to output.
	
		log.message() << "Writing native filter to \"" << outFile << "\"..." << std::endl;
		std::ofstream outStream(outFile, std::ios_base::out);
		ifpp::print(outStream, ifpp::PRINT_NATIVE, outFilter);
		outStream.close();

		// Copy the filter to the Path of Exile folder under My Documents.		
		
		if (documents) {
			// Get the actual file name (not directories) of the filter.
			size_t pos = baseName.find_last_of("/\\");
			std::string docFile;
			if (pos != std::string::npos) {
				docFile = baseName.substr(pos + 1);
			} else {
				docFile = baseName;
			}
			
			// Get the path to the documents folder.
			TCHAR docPath[MAX_PATH];
			if (!SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_PERSONAL, NULL, 0, docPath))) {
				throw std::runtime_error("Could not find path to the Path of Exile folder. Copy your filter there manually.");
			}
			docFile = std::string() + docPath + "\\My Games\\Path of Exile\\" + docFile + ".filter";
			
			log.message() << "Writing native filter to \"" << docFile << "\"..." << std::endl;
			std::ofstream docStream(docFile, std::ios_base::out);
			ifpp::print(docStream, ifpp::PRINT_NATIVE, outFilter);
			docStream.close();
		}
		
		log.message() << "Done." << std::endl << std::endl;
		
		log.message() << "IFPP finished." << std::endl;
		log.message() << "\t" << log.numWarnings << " warnings" << std::endl;
		log.message() << "\t" << log.numErrors << " errors" << std::endl;
		log.message() << "\t" << log.numCritical << " critical errors" << std::endl;
		
		logStream.close();
		return EXIT_SUCCESS;
	}
	catch (ifpp::InternalError & e) {
		log.message() << "INTERNAL ERROR: " << e.what() << std::endl;
		log.message() << "File: " << e.file << " line: " << e.line << std::endl;
		log.message() << "Processing aborted. Please report this issue at [link]." << std::endl;
		logStream.close();
		return EXIT_FAILURE;
	}
	catch (std::runtime_error & e) {
		log.error() << e.what() << std::endl;
		log.message() << "Processing aborted.";
		logStream.close();
		return EXIT_FAILURE;
	}
}